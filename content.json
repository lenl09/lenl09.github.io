{"pages":[{"title":"What is the Onominute?","text":"Explaining the name itself.Tom Scott defines the ‘onosecond’ as: The second after you make a terrible mistake. The second when you realise what you just did and that there’s nothing you can do about it, the second when all the now-inevitable consequences flash through your mind. It is the second after you send a text message to the wrong person, after you delete the wrong file, after you spill the secret that you thought they already knew. The “onosecond” is that stomach-dropping, breath-stopping moment when all you can do is say “oh, no”. The Onominute (or 60 onoseconds) is a collection of my documentation and notes for learning various scientific topics. The name itself refers to the average number of times I realized my mistakes while learning a new topic, in a single sitting. Some stuff ‘bout me!As an aspiring computational scientist, I loves to learn and read about mathematics, natural sciences, visual arts, design theory, and philosophy (especially metaphysics). My name is Nhan Luong (Luong Ha Tri Nhan) but most people know me as Len. I’m a Vietnamese student pursuing an Honours year in Computer Science at Monash University in Melbourne, Australia. Occasionally, I tend to just pick up my camera to go take random photos of cats or regular daily life stuff happening on the streets. I’m also trying to re-learn the piano, which I regrettably gave up on as a kid. My academic interests are scientific computing (specifically astronomy and physics), computer graphics (simulation and visualisation), and theoretical computer science. I’m hoping to be able to get involved in research projects in those areas! From now to July 2021, I will be focusing on my Honours thesis supervised by Professor Daniel Price and Dr. Max Cordeil, which is in interactive/immersive visualisation of particle-based fluid simulation for astrophysics. We will be visualising Prof. Daniel’s Smoothed Particle Hydrodynamics (SPH) simulations using the open-source IATK Unity3D toolkit developed by Dr. Max to interact with the fluid simulation in Virtual Reality. What is this site about, then?This will be the main platform where I will be publishing the notes I have taken while trying to learn new subjects and topics to the masses. I want to write them in a way that is accessible and understandable by as many people as possilbe (meaning minimal prerequisite knowledge), not just because I want more people to discover and appreciate the beauty of science but also because it will vastly improve my understanding of the topic. As this is meant as a shared learning experience, not a go-to teaching material, there will definitely be errors and I welcome all the feedbacks and suggestions that you may have while reading my contents. Please feel free to email me at lennemo09@gmail.com if you ever notice a mistake! I will hopefully try to post updates on my projects if there are any, as I want to document my experience working on them as well, recording all the mistakes and challenges I might have faced so it can be helpful in the future for me or some lost soul Googling for the same problem.","link":"/about/"}],"posts":[{"title":"Hello World - The Sequel","text":"Cover photo by Michael Dziedzic This is essentially the same as the previous post. Just for testing. Decomposition, algorithmic problem solving, and functions in Python1. DecompositionWhat is ‘decomposition’? Decomposition is one of the four cornerstones of Computer Science. It involves breaking down a complex problem or system into smaller parts that are more manageable and easier to understand. The smaller parts can then be examined and solved, or designed individually, as they are simpler to work with. (Source)In essence, decomposition involves breaking the problem down into steps. Each step can then be treated as an individual problem. Why does this matter?Decomposition is important for: Simplifying the problem Allowing different agents (people or machines) to work on different part of the problem.Very important for programming! The 3R’s rule: Reduce: replace sections of the algorithm with functions. Reuse: re-use the same functions for common tasks. For example, so far we have been using print() and other functions a lot in Python to do our work. These involves multiple steps to implement from scratch! Thus using the same functions save us a lot of time (and sanity)! Click here to find out what it is like to write our own print function. Recycle: easily extend and improve on existing functions. Wait, but what is an algorithm or a function? 2. Introduction to algorithmsWhat is an algorithm?In short, an algorithm is a sequence of steps to solve problems.A more easier way to think of an algorithm is to consider it to be like a recipe!For example, the following is a recipe/algorithm to make a chocolate cake: Melt chocolate and 2 tablespoons water in double boiler.When melted, stir in powdered sugar; add butter bit by bit.Set aside. Beat egg yolks until thick and lemon-colored, about 5 minutes.Gently fold in chocolate.Reheat slightly to melt chocolate, if necessary.Stir in rum and vanilla. Beat egg whites until foamy.Beat in 2 tablespoons sugar; beat until stiff peaks form.Gently fold whites into chocolate-yolk mixture.Pour into individual serving dishes.Chill at least 4 hours.Serve with whipped cream, if desired.Makes 6 to 8 servings. Another example of an algorithm is: Have a piece of A4 paper.Fold paper in half.Unfold and then fold the corners into the center line.Fold the top edges to the center.Fold the paper in half.Fold the sides down to meet the bottom edge of the paper. Question: What is the above algorithm aiming to do? What exactly makes an algorithm?In order to differentiate an algorithm from an arbitrary set of instructions, we need to have a definition for a proper algorithm: An algorithm is a finite sequence of steps written for an agent (e.g. person, computer) to solve a problem with the following properties: Definiteness: Each step must be precisely and unambiguously specified for an agent. Input: An algorithm can have zero or more inputs. Output: An algorithm must have one or more outputs. Effectiveness: Each step must be simple enough that they can be done exactly in a (reasonably) finite amount of time by the agent. Finiteness: The algorithm must always terminate after a finite number of steps (e.g. not in an infinite loop). Note: If all the above are satisfied except for Finiteness, it is called a process. Definiteness vs. EffectivenessThe 2 properties might be confusing at first but to better understand the difference, you can intepret them as: The agent following the instruction must: Definiteness: Understand WHAT to do. Effectiveness: be ABLE to do it.Let’s make an algorithm!First, I will show you how to write an algorithm to open a door. It is important to understand that there is no right algorithm for a problem, you can totally create another algorithm to open a door that is very different from mine and it would still be a valid algorithm (given that it meets all the properties defined above). Here is my algorithm on how to open a door:123456789101112131415161718192021222324252627Assumption: For doors with no handle or a handle designed to be rotated clockwise. Requires agent to have at least one hand.Algorithm:- Input: none- Output: statement as to the success of attempt1. Place left hand upon door agent may replace this with right hand at their discretion).2. If the door has a handle: a. Grasp the handle with alternate hand (or same hand if only have one). b. If handle can be rotated clockwise about connection with door: i. Rotate handle clockwise until it stops. ii. Push door. iii. If door begins to open: - Continue pushing door until open enough to step through. - Release handle. - Output: &quot;Door is open&quot; -&gt; Go to step 3. iv. Otherwise: - Pull door - If door begins to open: + Continue pulling until open enough to step through + Release handle + Output: &quot;Door is open&quot; -&gt; Go to step 3. - Otherwise: + Output: &quot;Door cannot be opened&quot; -&gt; Go to step 3. c. Otherwise: i. Output: &quot;Door cannot be opened&quot; -&gt; Go to step 3.3. End.Remember, you can write an entirely different algorithm from what I have done above but as long as it satisfies all the properties of an algorithm, it is to be considered a valid one. Another thing to notice is that the level of details I have included above is arbitrary chosen, at first you might thing the steps are too specific! But then you might wonder why I wasn’t being even more specific, like telling how to control your arm muscle to push the door? This is because Definiteness depends on the agent, we need to be clear enough that anyone who read our algorithm can understand exactly what to do and here I assume the person doesn’t know how to open a door so they might not know that you would need to push it. But because I assume it is a person, they must have already known what push means. If this was a robot however, you would need to specify how the robot uses its mechanical arm to do a pushing motion! Thus requiring your algorithm to be much more detailed. Computer scientists and software engineers solves real-world problems with computers all the time, and because computers have not yet evolved enough to understand the real world as much as we are, they need to be comfortable with reading, writing and understanding algorithms extremely well.Exercise (required): Write an algorithm on how to make an omelette (or rice or any type of food). Write this in a text file or on paper, not in Python.Extra reading (for fun - not required): Do you know the difference between a computer scientist and a software engineer? 3. Functions in PythonWhat is a function?Conceptually, a function is very similar to an algorithm but not exactly:Recall that algorithms have: Names Input: Zero or more Output: One or more Whereas, a function: May not have names, but usually do May or may not have input $\\approx$ Zero or more. Functions may either: Print a value (or values) Change an input value (or values) Return a value (or values) Knowing this, you’ll be thinking that we should make a function corresponding to each algorithm we have. This can work for now, but it’s usually not the case for more complicated algorithm (remember the section Decomposition). Simple printing functions in PythonHere’s the syntax for making a function in Python:123def this_is_my_function(my_name): print(&quot;Hello &quot; + my_name) print(&quot;Welcome to My Function!&quot;)Here, we use the def keyword to denote that we are creating a function! Following the def keyword (with a space!) is our function name, we can name this anything, I just call it this_is_my_function for simplicity. Right after the function name (without a space), you can see we have () - this is familiar! We’ve already seen this while using other built-in functions like print() and int() or str() or len(). Remember when we use those functions like print() we usually pass something inside () for the function to do its job with, right? Here with our function we can do the same as well. The thing(s) that we are passing inside () is called a parameter or argument to a function. In this case, our function this_is_my_function() have a parameter called my_name. So, how do we use our newly created function? Simple, just like print() or other functions we have used so far, simple call the function with the function’s name and pass in the required parameters:123456name_from_user = input(&quot;What is your name? &quot;)this_is_my_function(name_from_user)&gt;&gt;&gt; What is your name? ABCD&gt;&gt;&gt; Hello ABCD&gt;&gt;&gt; Welcome to My Function!Note that like print(), we can pass our string’s value directly as the parameter. In the above example I pass the string indirectly through a variable. The same function would still work if I called it with this_is_my_function(&quot;ABCD&quot;) instead.Another note that our function only exist within the Python file it was created in, unlike print() and other built-in functions, because our this_is_my_function function is not built-in. In later weeks we will find out how to use this function in other Python files! Exercise (required): Write an function to print out your name and age. Something like:123456def print_name_and_age(name,age): YOUR CODE HEREprint_name_and_age(&quot;Nikola Tesla&quot;,&quot;5555&quot;)&gt;&gt;&gt; &quot;Hello! My name is Nikola Tesla and I'm 5555 years old.&quot; Exercise (required): Write an function to print out the area of a circle given a radius as the parameter (you can use math.pi or your own value of $\\pi$):123456789def print_circle_area(radius): YOUR CODE HEREprint_circle_area(10)r = 20print_circle_area(r)&gt;&gt;&gt; 314.15926535&gt;&gt;&gt; 1256.63706143 More useful functions in PythonRecall from the What is a function? section, we mentioned that other than just printing out values, a function can also: Return a value (or values) Here is an example of a function that does not print a value but returns it:1234567891011121314def sum_first_two_item_of_list(my_list): first_item = my_list[0] second_item = my_list[1] return first_item + second_itemnew_list = [6,2,1.25,2.5]sum1 = sum_first_two_item_of_list(new_list)print(sum1)another_list = [2.1,3,16,22]print(sum_first_two_item_of_list(another_list))&gt;&gt;&gt; 8&gt;&gt;&gt; 5.1We can see that as the function returns a value using the return keyword at the end of the function, the call of the function is evaluated to be exactly the value that it would return! Hence we can use it to assign to a new variable like sum1 or use it directly inside a print()! Very convenient. Exercise (required): Remember our leap year problem? Here’s a program that prints the number of days a month have (knowing leap year is important because it determines the output of the input is “February”):1234567891011121314month = input(&quot;Enter month: &quot;)month = month[:3].lower() # What is this doing?if month == &quot;feb&quot;: year = int(input(&quot;Enter year: &quot;)) # Check if it is a leap year: if year%4==0 and (year%100!=0 or year%400==0): print(&quot;29 days&quot;) else: print(&quot;28 days&quot;)elif month==&quot;sep&quot; or month==&quot;apr&quot; or month==&quot;jun&quot; or month==&quot;nov&quot;: print(&quot;30 days&quot;)else: print(&quot;31 days&quot;)Notice that our function is now a bit harder to read and understand. Remember Decomposition? We should decompose this problem into 2 different problems: Check if it’s a leap year Return number of days in the month Which can be turned into 2 different functions! Your first task is to write the leap year function so that our program will become: 1234567891011121314151617181920def is_leap_year(year): YOUR CODE HERE # return True if leap year # return False if not a leap yearmonth = input(&quot;Enter month: &quot;)month = month[:3].lower() # What is this doing?if month == &quot;feb&quot;: year = int(input(&quot;Enter year: &quot;)) # Remember as is_leap_year returns True or False, # We can use it directly with if-else statement: if is_leap_year(year): print(&quot;29 days&quot;) else: print(&quot;28 days&quot;)elif month==&quot;sep&quot; or month==&quot;apr&quot; or month==&quot;jun&quot; or month==&quot;nov&quot;: print(&quot;30 days&quot;)else: print(&quot;31 days&quot;) Now our program is a bit easier to read. Readability is a very important in programming! But we can still decompose it better and make it even easier to understand. Recall that this program is essentially an algorithm! As such, we can present it with a function and gives it a name so people knows what is going on. Your next task is to turn the code we had before into the following structure:12345678910111213def is_leap_year(year): YOUR CODE HERE # return True if leap year # return False if not a leap yeardef get_days_in_month(month,year): YOUR CODE HERE # return &quot;__ days&quot; as a string!month = input(&quot;Enter month: &quot;)year = int(input(&quot;Enter year: &quot;))print(get_days_in_month(month,year))","link":"/2021/08/13/Hello-World-The-Sequel/"},{"title":"The Elegant Mathematical Basis of Ray tracing - What Makes 3D Graphics Realistic","text":"This is an essay I submitted for a collection of texts about promoting the beauty of mathematics to the masses at Monash. It goes into the mathematics of one of the most important concepts in computer graphics, but at a very fundamental level. The reader should be able to follow this text with high-school level maths. SypnosisFor most of my friends, the natural world, they understandably believe, is impulsive, emotional, unpredictable, overall imperfect, and should be appreciated as such but that is not the case at all. Mathematics, aside from representing how humanity sees the world, helps us human beings specify the once general, afloat phenomena and things, and through that, figuring out underlying patterns in the random and use them to our advantage. It is thanks to those exact abstract numbers and formulas that reinvented ideas once only existing in the form of imaginative thoughts, such as spellbound princesses and talking toys into colorful reality right in front of our eyes. In fact, it is thanks to mathematics that a heartwarming stories such that of a clownfish crossing the ocean to find his son could have been encapsulated in flat screens and tiny electric boxes in the first place, completely transforming and enhancing our cinematic experience. Many ingenious computational techniques are responsible for the visual masterpieces mentioned above, one of which, a method called “ray tracing”, will be investigated in detail throughout this essay. Our light, the real kindIn order to simulate realistic lighting, we must first understand what is real light. We see the world around us by receiving light rays that bounce off of other objects to our eyes. This light is emitted by a light source, such as the sun or a lightbulb. The process seems to be rather simple so it must be easy to recreate on a computer, mustn’t it? Yes and no. It is not difficult to create a system that naively imitates the real world on a computer but it is immensely expensive to do so computationally. A real light source continuously emits an infinite amount of light rays; each of the rays bounces a number of times before it is fully absorbed or reaches our eyes - a process that requires an incredible number of computations just to mimic a single light source whereas in a typical scene of a Pixar animation, there are usually dozens. A naive approach“But we can’t calculate an infinite number of rays!”, one might say, and that is correct! What we can do is to limit the number of rays but this leads to a dilemma: either we have enough rays to make our light realistic but takes a very long time to render, or a sufficiently fast render but incredibly unrealistic results. Furthermore, it is not likely that most of the rays emitted from the light source are going to reach our “eyes”, which means most of the number-crunching work would not be entirely useful to us. One simple solution, ray tracing A way to minimise the number of non-useful computations is to look at the problem backwards [1], or only taking into account the ones that we need: instead of starting our simulation from the light source, we start from our virtual eyes: the camera. A digital image is segmented into individual pixels and for each pixel, we cast out a ray to find what would appear on that pixel by finding the closest object with which the ray intersects. We now know the objects that would be appearing on the screen and their colors. To find out if our point of interest is in direct illumination or in shade, we use secondary rays that work in the same manner. This technique is called “ray tracing” because we are tracing rays around the scene. When we add secondary rays, we are tracing a “path” of rays and this extension is called, unsurprisingly, “path tracing”. A rather simple, yet powerful, mathematical intuitionPolygonsNow that we have gotten the gist of ray tracing, let’s find out how we can tell the computer to solve our problem. Every 3D object is made of quadrilaterals called polygons and each polygon can be triangulated into 2 triangles: Modelling our problemFinding out whether a ray is intersecting an object essentially means checking if the ray has intersected one of these triangles. Now let’s model our system into a math problem. First, we pick a position for our camera in a coordinate system and call that point C = (C_x,C_y,C_z). We then create a hypothetical image plane that represents a grid of the pixels that would eventually appear on the viewer’s screen. We pick a pixel P = (P_x,P_y,P_z) on our grid and cast a ray from C through P which intersects which a polygon at the point M. We can then represent our ray (R) using the 3-dimensional parametric form of the equation for the line going through C and P with the parameter t: R(t) = (1-t)C + tPWhich represents the following linear system: \\begin{cases} x(t) = (1-t)C_x + tP_x \\\\ y(t) = (1-t)C_y + tP_y \\\\ z(t) = (1-t)C_z + tP_z \\end{cases}Using this form we can easily write C as R(0) and P as R(1).For our polygon, we can write the implicit form of the plane equation going through our polygon: ax + by + cz + d = 0Finding MThe point M lies on the plane, we have: aM_x + bM_y + cM_z + d = 0M also lies on the ray, this corresponds to a value for t, t’ which returns our values for the coordinates of M: \\begin{cases} x(t') = (1-t')C_x + t'P_x = M_x \\\\ y(t') = (1-t')C_y + t'P_y = M_y \\\\ z(t') = (1-t')C_z + t'P_z = M_z \\end{cases}We now have a linear system of 4 unknowns (t', M_x, My, Mz)\\ with 4 equations: \\begin{cases} aM_x + bM_y + cM_z + d = 0 \\\\ M_x = (1-t')C_x + t'P_x \\\\ M_y = (1-t')C_y + t'P_y \\\\ M_z = (1-t')C_z + t'P_z \\end{cases}We substitute our ray equations for M into the plane equation for M to achieve an equation with a single unknown t’: a[(1-t')C_x + t'P_x] + b[(1-t')C_y + t'P_y] + c[(1-t')C_z + t'P_z] + d = 0A computer can solve this equation almost instantaneously for the value of t', afterward we can substitute t’ into our first system to get the coordinates of M. We now have our point: M = (M_x,M_y,M_z). Checking for intersectionThe next part of our problem is to examine if M lies within or outside our polygon. This does not require any more complicated mathematical tools than what we have been using, in fact it is simply an application of weighted averages. Let us imagine our polygon as the triangle EFG. The point M can be written as a weighted average of E, F and G as so: M = \\frac{k_1 E + k_2 F + k_3 G}{k_1 + k_2 + k_3}We can understand this as the larger the weight is for a vertex, the further away M is from that vertex relative to the other vertices, e.g., if k_1 = k_2 = k_3 then M is the same distance away from all three vertices (M is the center (or centroid) of the triangle EFG). If one of the weights is negative, however, then M is outside the triangle which corresponds to the fact that our ray does not intersect this polygon. Currently, our equation seems quite messy being a fraction of variables but there is one key fact that we can use to our advantage: as the weights represent the proportional distance between the vertices, we can scale the weights uniformly and it would not change the position of M thus we can limit the weights such that k_1 + k_2 + k_3 = 1 and therefore we can remove the denominator from our equation giving us: M = k_1 E + k_2F + k_3GWe can solve for the weights using the system of equations with 3 unknowns and 3 equations (again, this task only requires elementary row operations so the computer can solve it swiftly): \\begin{cases} M_x = k_1 E_x + k_2 F_x + k_3 G_x, \\\\ M_y = k_1 E_y + k_2 F_y + k_3 G_y, \\\\ M_z = k_1 E_z + k_2 F_z + k_3 G_z \\end{cases}We now got our weights k_1, k_2, k_3 and if none of the weights is negative, we have found that our ray intersects a polygon! Putting it all togetherAlthough we have only managed to figure out what color of the object that would appear on the screen at a pixel is, for realistic lighting we would also want to know if it is in shade. To do this instead of only sending out a single ray from a pixel, we send out a path of rays with each new rays originating from the intersection of the previous. We can use the same math we have used above only now instead of our point C, we choose the origin of our next ray to be M and the direction of the ray would be determined by the surface of the object (this information is included in the object’s shaders.) We have found a path tracing process for one pixel, all we need to do is to repeat this process for every other pixels of our image and luckily computers are quite keen of repetitive number crunching tasks like this (modern graphics processors can even do billions at the same time!). For a large scale production such as a Pixar’s animation, it is standard to use millions of rays for a single pixel and a few dozens or even hundreds bounces for each rays in order to achieve near-realistic lighting. For a marvel that is Toy Story 4, it took 60 to 160 hours to render one frame (this would be impossible if we use the aforementioned naive method) and the movie itself contains a few hundred thousands frames. This resulted in lighting and optical effects that is almost indifferentiable from real camera works. That’s simply how it all began!When most people think of advanced technologies they usually think of complex high-level mathematics but in fact, a lot of beautiful and complex creations, both natural or man-made, can be broken down into simple and elegant mathematics that everyone had already learned in school. Throughout this essay, we have discovered that beneath all the layers of abstraction of computer-generated graphics lies a set of simple highschool algebra homeworks.","link":"/2021/08/13/Ray-tracing/"},{"title":"Hello World","text":"Cover photo by Michael Dziedzic Welcome to the Onominute! This is a test post to see if the site layout is working or not. This post will likely disappear after a few hours so read it while you can!!! Below is what I wrote to tutor Python for high school students, it is served as a demo to test the formatting and display components of the website: Decomposition, algorithmic problem solving, and functions in Python1. DecompositionWhat is ‘decomposition’? Decomposition is one of the four cornerstones of Computer Science. It involves breaking down a complex problem or system into smaller parts that are more manageable and easier to understand. The smaller parts can then be examined and solved, or designed individually, as they are simpler to work with.(Source) In essence, decomposition involves breaking the problem down into steps. Each step can then be treated as an individual problem. Why does this matter?Decomposition is important for: Simplifying the problem Allowing different agents (people or machines) to work on different part of the problem.Very important for programming! The 3R’s rule: Reduce: replace sections of the algorithm with functions. Reuse: re-use the same functions for common tasks. For example, so far we have been using print() and other functions a lot in Python to do our work. These involves multiple steps to implement from scratch! Thus using the same functions save us a lot of time (and sanity)! Click here to find out what it is like to write our own print function. Recycle: easily extend and improve on existing functions. Wait, but what is an algorithm or a function? 2. Introduction to algorithmsWhat is an algorithm?In short, an algorithm is a sequence of steps to solve problems.A more easier way to think of an algorithm is to consider it to be like a recipe!For example, the following is a recipe/algorithm to make a chocolate cake: Melt chocolate and 2 tablespoons water in double boiler.When melted, stir in powdered sugar; add butter bit by bit.Set aside. Beat egg yolks until thick and lemon-colored, about 5 minutes.Gently fold in chocolate.Reheat slightly to melt chocolate, if necessary.Stir in rum and vanilla. Beat egg whites until foamy.Beat in 2 tablespoons sugar; beat until stiff peaks form.Gently fold whites into chocolate-yolk mixture.Pour into individual serving dishes.Chill at least 4 hours.Serve with whipped cream, if desired.Makes 6 to 8 servings. Another example of an algorithm is: Have a piece of A4 paper.Fold paper in half.Unfold and then fold the corners into the center line.Fold the top edges to the center.Fold the paper in half.Fold the sides down to meet the bottom edge of the paper. Question: What is the above algorithm aiming to do? What exactly makes an algorithm?In order to differentiate an algorithm from an arbitrary set of instructions, we need to have a definition for a proper algorithm: An algorithm is a finite sequence of steps written for an agent (e.g. person, computer) to solve a problem with the following properties: Definiteness: Each step must be precisely and unambiguously specified for an agent. Input: An algorithm can have zero or more inputs. Output: An algorithm must have one or more outputs. Effectiveness: Each step must be simple enough that they can be done exactly in a (reasonably) finite amount of time by the agent. Finiteness: The algorithm must always terminate after a finite number of steps (e.g. not in an infinite loop). Note: If all the above are satisfied except for Finiteness, it is called a process. Definiteness vs. EffectivenessThe 2 properties might be confusing at first but to better understand the difference, you can intepret them as: The agent following the instruction must: Definiteness: Understand WHAT to do. Effectiveness: be ABLE to do it.Let’s make an algorithm!First, I will show you how to write an algorithm to open a door. It is important to understand that there is no right algorithm for a problem, you can totally create another algorithm to open a door that is very different from mine and it would still be a valid algorithm (given that it meets all the properties defined above). Here is my algorithm on how to open a door:123456789101112131415161718192021222324252627Assumption: For doors with no handle or a handle designed to be rotated clockwise. Requires agent to have at least one hand.Algorithm:- Input: none- Output: statement as to the success of attempt1. Place left hand upon door agent may replace this with right hand at their discretion).2. If the door has a handle: a. Grasp the handle with alternate hand (or same hand if only have one). b. If handle can be rotated clockwise about connection with door: i. Rotate handle clockwise until it stops. ii. Push door. iii. If door begins to open: - Continue pushing door until open enough to step through. - Release handle. - Output: &quot;Door is open&quot; -&gt; Go to step 3. iv. Otherwise: - Pull door - If door begins to open: + Continue pulling until open enough to step through + Release handle + Output: &quot;Door is open&quot; -&gt; Go to step 3. - Otherwise: + Output: &quot;Door cannot be opened&quot; -&gt; Go to step 3. c. Otherwise: i. Output: &quot;Door cannot be opened&quot; -&gt; Go to step 3.3. End.Remember, you can write an entirely different algorithm from what I have done above but as long as it satisfies all the properties of an algorithm, it is to be considered a valid one. Another thing to notice is that the level of details I have included above is arbitrary chosen, at first you might thing the steps are too specific! But then you might wonder why I wasn’t being even more specific, like telling how to control your arm muscle to push the door? This is because Definiteness depends on the agent, we need to be clear enough that anyone who read our algorithm can understand exactly what to do and here I assume the person doesn’t know how to open a door so they might not know that you would need to push it. But because I assume it is a person, they must have already known what push means. If this was a robot however, you would need to specify how the robot uses its mechanical arm to do a pushing motion! Thus requiring your algorithm to be much more detailed. Computer scientists and software engineers solves real-world problems with computers all the time, and because computers have not yet evolved enough to understand the real world as much as we are, they need to be comfortable with reading, writing and understanding algorithms extremely well.Exercise (required): Write an algorithm on how to make an omelette (or rice or any type of food). Write this in a text file or on paper, not in Python.Extra reading (for fun - not required): Do you know the difference between a computer scientist and a software engineer? 3. Functions in PythonWhat is a function?Conceptually, a function is very similar to an algorithm but not exactly:Recall that algorithms have: Names Input: Zero or more Output: One or more Whereas, a function: May not have names, but usually do May or may not have input $\\approx$ Zero or more. Functions may either: Print a value (or values) Change an input value (or values) Return a value (or values) Knowing this, you’ll be thinking that we should make a function corresponding to each algorithm we have. This can work for now, but it’s usually not the case for more complicated algorithm (remember the section Decomposition). Simple printing functions in PythonHere’s the syntax for making a function in Python:123def this_is_my_function(my_name): print(&quot;Hello &quot; + my_name) print(&quot;Welcome to My Function!&quot;)Here, we use the def keyword to denote that we are creating a function! Following the def keyword (with a space!) is our function name, we can name this anything, I just call it this_is_my_function for simplicity. Right after the function name (without a space), you can see we have () - this is familiar! We’ve already seen this while using other built-in functions like print() and int() or str() or len(). Remember when we use those functions like print() we usually pass something inside () for the function to do its job with, right? Here with our function we can do the same as well. The thing(s) that we are passing inside () is called a parameter or argument to a function. In this case, our function this_is_my_function() have a parameter called my_name. So, how do we use our newly created function? Simple, just like print() or other functions we have used so far, simple call the function with the function’s name and pass in the required parameters:123456name_from_user = input(&quot;What is your name? &quot;)this_is_my_function(name_from_user)&gt;&gt;&gt; What is your name? ABCD&gt;&gt;&gt; Hello ABCD&gt;&gt;&gt; Welcome to My Function!Note that like print(), we can pass our string’s value directly as the parameter. In the above example I pass the string indirectly through a variable. The same function would still work if I called it with this_is_my_function(&quot;ABCD&quot;) instead.Another note that our function only exist within the Python file it was created in, unlike print() and other built-in functions, because our this_is_my_function function is not built-in. In later weeks we will find out how to use this function in other Python files! Exercise (required): Write an function to print out your name and age. Something like:123456def print_name_and_age(name,age): YOUR CODE HEREprint_name_and_age(&quot;Nikola Tesla&quot;,&quot;5555&quot;)&gt;&gt;&gt; &quot;Hello! My name is Nikola Tesla and I'm 5555 years old.&quot; Exercise (required): Write an function to print out the area of a circle given a radius as the parameter (you can use math.pi or your own value of $\\pi$):123456789def print_circle_area(radius): YOUR CODE HEREprint_circle_area(10)r = 20print_circle_area(r)&gt;&gt;&gt; 314.15926535&gt;&gt;&gt; 1256.63706143 More useful functions in PythonRecall from the What is a function? section, we mentioned that other than just printing out values, a function can also: Return a value (or values) Here is an example of a function that does not print a value but returns it:1234567891011121314def sum_first_two_item_of_list(my_list): first_item = my_list[0] second_item = my_list[1] return first_item + second_itemnew_list = [6,2,1.25,2.5]sum1 = sum_first_two_item_of_list(new_list)print(sum1)another_list = [2.1,3,16,22]print(sum_first_two_item_of_list(another_list))&gt;&gt;&gt; 8&gt;&gt;&gt; 5.1We can see that as the function returns a value using the return keyword at the end of the function, the call of the function is evaluated to be exactly the value that it would return! Hence we can use it to assign to a new variable like sum1 or use it directly inside a print()! Very convenient. Exercise (required): Remember our leap year problem? Here’s a program that prints the number of days a month have (knowing leap year is important because it determines the output of the input is “February”):1234567891011121314month = input(&quot;Enter month: &quot;)month = month[:3].lower() # What is this doing?if month == &quot;feb&quot;: year = int(input(&quot;Enter year: &quot;)) # Check if it is a leap year: if year%4==0 and (year%100!=0 or year%400==0): print(&quot;29 days&quot;) else: print(&quot;28 days&quot;)elif month==&quot;sep&quot; or month==&quot;apr&quot; or month==&quot;jun&quot; or month==&quot;nov&quot;: print(&quot;30 days&quot;)else: print(&quot;31 days&quot;)Notice that our function is now a bit harder to read and understand. Remember Decomposition? We should decompose this problem into 2 different problems: Check if it’s a leap year Return number of days in the month Which can be turned into 2 different functions! Your first task is to write the leap year function so that our program will become: 1234567891011121314151617181920def is_leap_year(year): YOUR CODE HERE # return True if leap year # return False if not a leap yearmonth = input(&quot;Enter month: &quot;)month = month[:3].lower() # What is this doing?if month == &quot;feb&quot;: year = int(input(&quot;Enter year: &quot;)) # Remember as is_leap_year returns True or False, # We can use it directly with if-else statement: if is_leap_year(year): print(&quot;29 days&quot;) else: print(&quot;28 days&quot;)elif month==&quot;sep&quot; or month==&quot;apr&quot; or month==&quot;jun&quot; or month==&quot;nov&quot;: print(&quot;30 days&quot;)else: print(&quot;31 days&quot;) Now our program is a bit easier to read. Readability is a very important in programming! But we can still decompose it better and make it even easier to understand. Recall that this program is essentially an algorithm! As such, we can present it with a function and gives it a name so people knows what is going on. Your next task is to turn the code we had before into the following structure:12345678910111213def is_leap_year(year): YOUR CODE HERE # return True if leap year # return False if not a leap yeardef get_days_in_month(month,year): YOUR CODE HERE # return &quot;__ days&quot; as a string!month = input(&quot;Enter month: &quot;)year = int(input(&quot;Enter year: &quot;))print(get_days_in_month(month,year))","link":"/2021/08/12/hello-world/"}],"tags":[{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"Hello","slug":"Hello","link":"/tags/Hello/"},{"name":"mathematics","slug":"mathematics","link":"/tags/mathematics/"},{"name":"computer graphics","slug":"computer-graphics","link":"/tags/computer-graphics/"},{"name":"3d","slug":"3d","link":"/tags/3d/"},{"name":"ray-tracing","slug":"ray-tracing","link":"/tags/ray-tracing/"}],"categories":[{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"Mathematics","slug":"Mathematics","link":"/categories/Mathematics/"}]}